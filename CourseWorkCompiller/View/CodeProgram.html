<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Справка</title>
    <style>
        html, body {
            height: 100%;
            width: 100%;
            margin: 0px;
        }
        .nav {
            display: flex;
            justify-content: left;
            background-color: #555555;
        }

        .ul-nav {
            display: flex;
            list-style-type: none;
            margin: 0;
            padding: 0;
        }

        .li-item-nav {
            color: white;
            cursor: pointer;
            padding: 20px 30px 20px 30px;
        }

        .li-item-nav:first-child {
            cursor: default;
        }
        .li-item-nav:first-child:hover {
            background-color: #555555;
        }

        .li-item-nav:hover {
            background-color: #04aa6d;
        }

        .mainInfoContainer {
            margin-top: 20px;
        }

        .dropbtn {
            background-color: transparent;
            color: white;
            font-size: 16px;
            border: none;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f1f1f1;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
        }

        .dropdown-content div {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }

        pre {
            margin: 10px 50px;
            padding: 10px;
            border: 1px solid black;
            font-size: 16px;
        }

        .pCode{
            margin-left: 50px;
            font-size: 20px;
        }

        .pHead{
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 24px;
        }

        .dropdown-content div:hover {background-color: #ddd;}

        .dropdown:hover .dropdown-content {display: block;}

        .dropdown:hover .dropbtn {background-color: transparent;}

        .reference-list {
            counter-reset: item;
            margin: 10px 150px
        }
        .reference {
            margin-bottom: 25px;
            padding-left: 30px;
            text-indent: -30px;
            text-align: justify;
        }
        .reference:before {
            content: counter(item) ".";
            counter-increment: item;
            padding-right: 10px;
            color: #2c5282;
            font-weight: bold;
        }
        .author {
            font-weight: bold;
        }
        .title {
            font-style: italic;
        }
        .publisher {
            font-style: normal;
        }
        .electronic {
            color: #2b6cb0;
        }
        .url {
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #4a5568;
        }
        .translation {
            font-size: 0.9em;
            color: #4a5568;
        }

        .main-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            color: #555555;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .section-title {
            color: #555555;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 30px;
            font-weight: 600;
        }
        .subsection-title {
            color: #04aa6d;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 500;
        }
        .command-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .command-item {
            margin-bottom: 12px;
            padding: 12px 15px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            border-left: 4px solid #04aa6d;
        }
        .command-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .command {
            color: #04aa6d;
            font-weight: bold;
            font-family: Consolas, monospace;
            padding: 2px 5px;
            background-color: #f0f0f0;
            border-radius: 3px;
        }

        .about-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            color: #555555;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .about-title {
            color: #555555;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 0;
            font-weight: 600;
        }
        .about-text {
            margin-bottom: 12px;
            padding: 0;
        }
        .about-highlight {
            color: #04aa6d;
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 3px;
            background-color: #f0f0f0;
        }

        .grammar-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            color: #555555;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .grammar-title {
            color: #555555;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 0;
            font-weight: 600;
        }

        .grammar-description {
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .production-rule {
            font-family: Consolas, monospace;
            padding: 8px 15px;
            margin-bottom: 8px;
            background-color: #f9f9f9;
            border-left: 4px solid #04aa6d;
            border-radius: 4px;
        }

        .terminal {
            color: #04aa6d;
            font-weight: bold;
        }

        .non-terminal {
            color: #2c3e50;
            font-weight: 500;
        }

        .grammar-definition {
            margin-top: 25px;
            padding-top: 15px;
            border-top: 1px dashed #ddd;
        }

        .definition-text {
            margin-bottom: 15px;
        }

        .definition-list {
            padding-left: 20px;
        }

        .definition-term {
            margin-bottom: 8px;
            font-family: Consolas, monospace;
        }

        .grammar-type {
            font-weight: 600;
            color: #04aa6d;
        }

        .document-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            color: #333;
            line-height: 1.6;
        }

        .document-title {
            color: #2c3e50;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 0;
        }

        .document-description {
            font-size: 1.1em;
            color: #555;
            margin-bottom: 30px;
        }

        .section-title {
            color: #2980b9;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .section-text {
            margin-bottom: 20px;
        }

        .code-inline {
            font-family: Consolas, monospace;
            color: #d63384;
            background-color: #f8f9fa;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .code-block {
            background-color: #f8f9fa;
            border-left: 4px solid #04aa6d;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 4px 4px 0;
            overflow-x: auto;
        }

        .code-block pre {
            margin: 0;
            font-family: Consolas, monospace;
            color: #333;
        }

        .examples-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .example-item {
            font-family: Consolas, monospace;
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-left: 3px solid #6f42c1;
            border-radius: 3px;
        }

        .test-cases {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 25px;
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .test-cases-title {
            color: #2c3e50;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 0;
        }

        .test-case {
            margin: 20px 0;
        }

        .case-title {
            color: #04aa6d;
            margin-bottom: 10px;
        }

        .input-code {
            font-family: Consolas, monospace;
            background-color: #f0f0f0;
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .output-errors {
            background-color: #fff;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #e74c3c;
        }

        .error-message {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed #eee;
        }

        .error-location {
            color: #555;
            font-weight: 500;
            display: inline-block;
            min-width: 150px;
        }

        .error-suggestion {
            color: #04aa6d;
            font-style: italic;
        }

        .case-divider {
            height: 1px;
            background-color: #ddd;
            margin: 25px 0;
        }

        .grammar-analysis {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 25px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .analysis-title {
            color: #2c3e50;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 0;
            font-size: 1.5em;
        }

        .analysis-description {
            line-height: 1.6;
            color: #555;
            margin-bottom: 15px;
        }

        .math-notation {
            font-family: 'Consolas', monospace;
            color: #9b59b6;
            font-weight: 500;
        }

        .grammar-type {
            color: #04aa6d;
            font-weight: 600;
        }

        .graph-wrapper {
            margin: 25px 0;
            border: 1px solid #eee;
            border-radius: 6px;
            padding: 15px;
            background-color: #f8f9fa;
        }

        .graph-image {
            text-align: center;
            margin-bottom: 20px;
        }

        .graph-image img {
            max-width: 100%;
            height: auto;
        }

        .graph-legend {
            background-color: white;
            padding: 15px;
            border-radius: 4px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .line-style {
            width: 40px;
            height: 2px;
            margin-right: 10px;
        }

        .solid {
            background-color: #04aa6d;
        }

        .dashed {
            background: repeating-linear-gradient(to right, #e74c3c, #e74c3c 3px, transparent 3px, transparent 6px);
        }

        .legend-label {
            font-size: 0.9em;
            color: #555;
        }

        .analysis-summary {
            font-style: italic;
            color: #2980b9;
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
<div style="display: flex; flex-direction: column">
    <p class="pHead">Исходный код программы</p>
    <div>
        <p class="pCode">Lexemes.cs</p>
        <code>
                            <pre>
namespace CourseWorkCompiller.Model;

public static class Lexemes
{
    public static Dictionary<string, TokenTypeEnum> Lexems = new Dictionary<string, TokenTypeEnum>
    {
        {",", TokenTypeEnum.Comma},
        { ";", TokenTypeEnum.Semicolon },
        { "(", TokenTypeEnum.OpenParenthesis },
        { ")", TokenTypeEnum.CloseParenthesis },
        { " ", TokenTypeEnum.Space },
    };

    public static string getLexemes(TokenTypeEnum lexeme)
    {
        foreach (var kvp in Lexems)
        {
            if (kvp.Value == lexeme)
            {
                return kvp.Key;
            }
        }
        return " ";
    }
}
                            </pre>
        </code>
    </div>
    <div>
        <p class="pCode">Lexer.cs</p>
        <code>
                            <pre>
using System.Text.RegularExpressions;
using System.Windows.Documents;

namespace CourseWorkCompiller.Model;

public class Lexer
{
    string pattern = @"\\bint\\b|\\bchar\\b|\\bvoid\\b|\\bfloat\\b|;| |\\( |\\)|,|[a-zA-Z][a-zA-Z0-9]*|[^\\s]";
    public List<Token> GetLexemes(string text)
    {
        List<string> strings = text.Split('\\n').ToList();
        List<Token> tokens = new List<Token>();
        Regex regex = new Regex(pattern);
        for (int i = 0; i < strings.Count; i++)
        {
            MatchCollection matches = regex.Matches(strings[i]);
            foreach (Match match in matches)
            {
                switch (match.Value)
                {
                    case "int":
                        tokens.Add(new Token(i+1, match.Index, match.Length + match.Index, $"Найдено ключевое слово: '{match.Value}'", match.Value));
                        break;
                    case "char":
                        tokens.Add(new Token(i+1, match.Index, match.Length + match.Index, $"Найдено ключевое слово: '{match.Value}'",match.Value));
                        break;
                    case "void":
                        tokens.Add(new Token(i+1, match.Index, match.Length + match.Index, $"Найдено ключевое слово: '{match.Value}'", match.Value));
                        break;
                    case "float":
                        tokens.Add(new Token(i+1, match.Index, match.Length + match.Index, $"Найдено ключевое слово: '{match.Value}'", match.Value));
                        break;
                    case ";":
                        tokens.Add(new Token(i+1, match.Index, match.Length + match.Index, $"Найден символ: '{match.Value}'", match.Value));
                        break;
                    case " ":
                        tokens.Add(new Token(i+1, match.Index, match.Length + match.Index, $"Найден разделитель: '{match.Value}'", match.Value));
                        break;
                    case "(":
                        tokens.Add(new Token(i+1, match.Index, match.Length + match.Index, $"Найдена открывающая скобка: '{match.Value}'", match.Value));
                        break;
                    case ")":
                        tokens.Add(new Token(i+1, match.Index, match.Length + match.Index, $"Найдена закрывающая скобка: '{match.Value}'", match.Value));
                        break;
                    case ",":
                        tokens.Add(new Token(i+1, match.Index, match.Length + match.Index, $"Найден разделитель аргументов: '{match.Value}'", match.Value));
                        break;
                    default:
                        if (Regex.IsMatch(match.Value, @"[a-zA-Z][a-zA-Z0-9]*"))
                        {
                            tokens.Add(new Token(i+1, match.Index, match.Length + match.Index, $"Найден идентификатор: '{match.Value}'", match.Value));
                        }
                        else
                        {
                            tokens.Add(new Token(i+1, match.Index, match.Length + match.Index, $"Найден недопустимый символ: '{match.Value}'", match.Value));
                        }
                        break;
                }
            }
        }
        return tokens;
    }
}
                            </pre>
        </code>
    </div>
    <div>
        <p class="pCode">Token.cs</p>
        <code>
                            <pre>
using System.Text.RegularExpressions;

namespace CourseWorkCompiller.Model;

public class Token
{
    public static Dictionary<string, (string token, TokenTypeEnum tokenType)> tokens = new Dictionary<string, (string, TokenTypeEnum)>
    {
        { @",", ("COMMA", TokenTypeEnum.Comma) },
        { @"\\bint\\b", ("INT", TokenTypeEnum.Int) },
        { @"\\bchar\\b", ("CHAR", TokenTypeEnum.Char) },
        { @"\\bvoid\\b", ("VOID", TokenTypeEnum.Void) },
        { @"\\bfloat\\b", ("FLOAT", TokenTypeEnum.Float) },
        { @";", ("SEMICOLON", TokenTypeEnum.Semicolon) },
        { @"\\(", ("OPEN_PARENTHESIS", TokenTypeEnum.OpenParenthesis) },
        { @"\\)", ("CLOSE_PARENTHESIS", TokenTypeEnum.CloseParenthesis) },
        { @"[a-zA-Z][a-zA-Z0-9]*", ("IDENTIFIER", TokenTypeEnum.Identifier) },
        { @"[^\\s]", ("INVALID", TokenTypeEnum.Invalid) },
        { @" ", ("SPACE", TokenTypeEnum.Space) },
    };
    public int Line {get; set;}
    public int StartIndex {get; set;}
    public int EndIndex {get; set;}
    public string Message {get; set;}
    public string Term {get; set;}
    public string UnTerm {get; set;}
    public TokenTypeEnum Code {get; set;}

    public Token(int line, int startIndex, int endIndex, string message, string text)
    {
        Line = line;
        StartIndex = startIndex;
        EndIndex = endIndex;
        Message = message;
        Term = text;
        UnTerm = ParseToken(text).Item1;
        Code = ParseToken(text).Item2;
    }


    private (string, TokenTypeEnum) ParseToken(string token)
    {
        foreach (var tokensReg in tokens)
        {
            if (Regex.IsMatch(token, tokensReg.Key))
                return tokensReg.Value;
        }
        return ("INVALID", TokenTypeEnum.Invalid);
    }
}
                            </pre>
        </code>
    </div>
    <div>
        <p class="pCode">TokenTypeEnum.cs</p>
        <code>
                            <pre>
namespace CourseWorkCompiller.Model;

public enum TokenTypeEnum
{
    Int = 1,
    Char = 2,
    Void = 3,
    Float = 4,
    Identifier = 5,
    Space = 6,
    OpenParenthesis = 7,
    CloseParenthesis = 8,
    Comma = 9,
    Semicolon = 10,
    Invalid = 11,
}
                            </pre>
        </code>
    </div>
    <div>
        <p class="pCode">ErrorToken.cs</p>
        <code>
                            <pre>
namespace CourseWorkCompiller.Model.Parser;

public class ErrorToken
{
    public string ErrorMessage { get; set; }
    public int Line { get; set; }
    public int Index { get; set; }
    public ErrorTokenType ErrorType { get; set; }

    public ErrorToken(string message, int line, int index, ErrorTokenType errorType)
    {
        ErrorMessage = message;
        Line = line;
        Index = index;
        ErrorType = errorType;
    }
}
                            </pre>
        </code>
    </div>
    <div>
        <p class="pCode">ErrorTokenType</p>
        <code>
                            <pre>
namespace CourseWorkCompiller.Model.Parser;

public enum ErrorTokenType
{
    PUSH,
    REPLACE,
    DELETE,
}
                            </pre>
        </code>
    </div>
    <div>
        <p class="pCode">Parser.cs</p>
        <code>
                            <pre>
using System.Windows.Documents;

namespace CourseWorkCompiller.Model.Parser;

public class Parser
{
    List<ErrorToken> errors = new List<ErrorToken>();
    List<List<Token>> tokens = new List<List<Token>>();
    
    public List<ErrorToken> StartParse(List<Token> tokensGet)
    {
        errors.Clear();
        tokens.Clear();
        getLinesTokens(tokensGet);
        foreach (var listTokens in tokens)
        {
            OneListTokenRecursiveParser parser = new OneListTokenRecursiveParser(listTokens);
            errors.AddRange(parser.parse());
        }
        return errors;
    }

    public void getLinesTokens(List<Token> tokensList)
    {
        tokens = tokensList.GroupBy(ter => ter.Line)
            .Select(group => group.ToList())
            .ToList();
    }
}
                            </pre>
        </code>
    </div>
    <div>
        <p class="pCode">OneListTokenRecursiveParser.cs</p>
        <code>
                        <pre>

partial class OneListTokenRecursiveParser
{
    private List<Token> tokensList = new List<Token>();

    public OneListTokenRecursiveParser(List<Token> _tokensList)
    {
        tokensList = _tokensList;
    }

    public List<ErrorToken> parse()
    {
        int currentPosition = 0;
        List<ErrorToken> errors = new List<ErrorToken>();
        return start(currentPosition, errors);
    }


    private List<ErrorToken> start(int currentPosition, List<ErrorToken> errors)
    {
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        
        currentPosition = skipNotValid(currentPosition,errors);
        if (tokensList[currentPosition].Code == TokenTypeEnum.Space)
        {
            return start(currentPosition + 1, errors);
        }

        TokenTypeEnum currentType = tokensList[currentPosition].Code;
        if (currentType == TokenTypeEnum.Int ||
            currentType == TokenTypeEnum.Char ||
            currentType == TokenTypeEnum.Float ||
            currentType == TokenTypeEnum.Void)
        {
            return spaceAfterTypeFunc(currentPosition + 1, errors);
        }
        
        return GetMinErrorList(
            spaceAfterTypeFunc(currentPosition, CreateErrorListType(currentPosition, ErrorTokenType.PUSH, errors, tokensList[currentPosition].Line)),
            spaceAfterTypeFunc(currentPosition + 1, CreateErrorListType(currentPosition, ErrorTokenType.REPLACE, errors, tokensList[currentPosition].Line)),
            start(currentPosition + 1, CreateErrorListType(currentPosition, ErrorTokenType.DELETE, errors, tokensList[currentPosition].Line))
            );
    }


    private List<ErrorToken> spaceAfterTypeFunc(int currentPosition, List<ErrorToken> errors)
    {
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        
        currentPosition = skipNotValid(currentPosition,errors);
        if (tokensList[currentPosition].Code != TokenTypeEnum.Space)
        {
            return GetMinErrorList(
                funcName(currentPosition,
                    CreateErrorList(currentPosition, TokenTypeEnum.Space, ErrorTokenType.PUSH, errors,
                        tokensList[currentPosition].Line)),
                funcName(currentPosition + 1,
                    CreateErrorList(currentPosition, TokenTypeEnum.Space, ErrorTokenType.REPLACE, errors,
                        tokensList[currentPosition].Line)),
                spaceAfterTypeFunc(currentPosition + 1,
                    CreateErrorList(currentPosition, TokenTypeEnum.Space, ErrorTokenType.DELETE, errors,
                        tokensList[currentPosition].Line))
            );
        }
        
        return funcName(currentPosition + 1, errors);
    }

    private List<ErrorToken> funcName(int currentPosition, List<ErrorToken> errors)
    {
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        currentPosition = skipNotValid(currentPosition, errors);
        if (tokensList[currentPosition].Code == TokenTypeEnum.Space)
        {
            return funcName(currentPosition + 1, errors);
        }

        if (tokensList[currentPosition].Code != TokenTypeEnum.Identifier)
        {
            return GetMinErrorList(
                openParenthesis(currentPosition,
                    CreateErrorList(currentPosition, TokenTypeEnum.Identifier, ErrorTokenType.PUSH, errors,
                        tokensList[currentPosition].Line)),
                openParenthesis(currentPosition + 1,
                    CreateErrorList(currentPosition, TokenTypeEnum.Identifier, ErrorTokenType.REPLACE, errors,
                        tokensList[currentPosition].Line)),
                funcName(currentPosition + 1,
                    CreateErrorList(currentPosition, TokenTypeEnum.Identifier, ErrorTokenType.DELETE, errors,
                        tokensList[currentPosition].Line))
            );
        }
        return openParenthesis(currentPosition + 1, errors);
    }


    private List<ErrorToken> openParenthesis(int currentPosition, List<ErrorToken> errors)
    {
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        
        currentPosition = skipNotValid(currentPosition, errors);
        if (tokensList[currentPosition].Code == TokenTypeEnum.OpenParenthesis && tokensList[currentPosition + 1].Code == TokenTypeEnum.Semicolon)
        {
            errors.Add(new ErrorToken("Вставить лексему: ')'", tokensList[currentPosition].Line, currentPosition, ErrorTokenType.PUSH));
            return semicolon(currentPosition + 1, errors);
        }
        if (tokensList[currentPosition].Code != TokenTypeEnum.OpenParenthesis)
        {
            return GetMinErrorList(
                nextAfterOpenParenthesis(currentPosition, CreateErrorList(currentPosition, TokenTypeEnum.OpenParenthesis, ErrorTokenType.PUSH, errors, tokensList[currentPosition].Line)),
                nextAfterOpenParenthesis(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.OpenParenthesis, ErrorTokenType.REPLACE, errors, tokensList[currentPosition].Line)),
                openParenthesis(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.OpenParenthesis, ErrorTokenType.DELETE, errors, tokensList[currentPosition].Line))
            );
        }
        
        return nextAfterOpenParenthesis(currentPosition + 1, errors);
    }

    private List<ErrorToken> nextAfterOpenParenthesis(int currentPosition, List<ErrorToken> errors)
    {
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        currentPosition = skipNotValid(currentPosition, errors);
        if (tokensList[currentPosition].Code == TokenTypeEnum.CloseParenthesis)
        {
            return semicolon(currentPosition + 1, errors);
        } else if (tokensList[currentPosition].Code == TokenTypeEnum.Int ||
                   tokensList[currentPosition].Code == TokenTypeEnum.Char ||
                   tokensList[currentPosition].Code == TokenTypeEnum.Float ||
                   tokensList[currentPosition].Code == TokenTypeEnum.Void)
        {
            return spaceAfterArgType(currentPosition + 1, errors);
        } else if ((currentPosition + 1) < tokensList.Count && tokensList[currentPosition].Code == TokenTypeEnum.Identifier && tokensList[currentPosition + 1].Code != TokenTypeEnum.Semicolon)
        {
            return argType(currentPosition, errors);
        }

        return GetMinErrorList(
            semicolon(currentPosition, CreateErrorList(currentPosition, TokenTypeEnum.CloseParenthesis, ErrorTokenType.PUSH, errors, tokensList[currentPosition].Line)),
            semicolon(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.CloseParenthesis, ErrorTokenType.REPLACE, errors, tokensList[currentPosition].Line)),
            nextAfterOpenParenthesis(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.CloseParenthesis, ErrorTokenType.DELETE, errors, tokensList[currentPosition].Line))
        );
    }

    private List<ErrorToken> semicolon(int currentPosition, List<ErrorToken> errors)
    {
        currentPosition = skipNotValid(currentPosition, errors);
        if (currentPosition >= tokensList.Count)
        {
            errors.Add(
                new ErrorToken(
                    CreateErrorMessage(TokenTypeEnum.Semicolon, ErrorTokenType.PUSH, currentPosition),
                    tokensList[currentPosition-1].Line,
                    currentPosition-1, ErrorTokenType.PUSH
            ));
            return errors;
        }

        if (tokensList[currentPosition].Code == TokenTypeEnum.Space)
        {
            return semicolon(currentPosition + 1, errors);
        }

        if (tokensList[currentPosition].Code != TokenTypeEnum.Semicolon)
        {
            errors.Add(
                new ErrorToken(
                    CreateErrorMessage(TokenTypeEnum.Semicolon, ErrorTokenType.DELETE, currentPosition),
                    tokensList[currentPosition].Line,
                    currentPosition,
                    ErrorTokenType.DELETE));
            semicolon(currentPosition + 1, errors);
        }
        return errors;
    }

    private List<ErrorToken> spaceAfterArgType(int currentPosition, List<ErrorToken> errors)
    {
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        currentPosition = skipNotValid(currentPosition, errors);
        if (tokensList[currentPosition].Code != TokenTypeEnum.Space)
        {
            return GetMinErrorList(
                argName(currentPosition, CreateErrorList(currentPosition, TokenTypeEnum.Space, ErrorTokenType.PUSH, errors, tokensList[currentPosition].Line)),
                argName(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.Space, ErrorTokenType.REPLACE, errors, tokensList[currentPosition].Line)),
                spaceAfterArgType(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.Space, ErrorTokenType.DELETE, errors, tokensList[currentPosition].Line))
            );
        }
        return argName(currentPosition + 1, errors);
    }

    private List<ErrorToken> argName(int currentPosition, List<ErrorToken> errors)
    {
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        currentPosition = skipNotValid(currentPosition, errors);
        if (tokensList[currentPosition].Code == TokenTypeEnum.Space)
        {
            return argName(currentPosition + 1, errors);
        }

        if (tokensList[currentPosition].Code != TokenTypeEnum.Identifier)
        {
            return GetMinErrorList(
                nextAfterArgName(currentPosition, CreateErrorList(currentPosition, TokenTypeEnum.Identifier, ErrorTokenType.PUSH, errors, tokensList[currentPosition].Line)),
                nextAfterArgName(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.Identifier, ErrorTokenType.REPLACE, errors, tokensList[currentPosition].Line)),
                argName(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.Identifier, ErrorTokenType.DELETE, errors, tokensList[currentPosition].Line))
                );
        }

        return nextAfterArgName(currentPosition + 1, errors);
    }

    private List<ErrorToken> nextAfterArgName(int currentPosition, List<ErrorToken> errors)
    {
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        
        if (tokensList[currentPosition].Code == TokenTypeEnum.Comma)
        {
            return spaceComma(currentPosition + 1, errors);
        }
        else if(tokensList[currentPosition].Code == TokenTypeEnum.Int ||
                tokensList[currentPosition].Code == TokenTypeEnum.Char ||
                tokensList[currentPosition].Code == TokenTypeEnum.Float ||
                tokensList[currentPosition].Code == TokenTypeEnum.Void)
        {
            return spaceAfterArgType(currentPosition + 1, errors);
        }
        else if (tokensList[currentPosition].Code == TokenTypeEnum.CloseParenthesis)
        {
            return semicolon(currentPosition + 1, errors);
        }
        if (tokensList[currentPosition].Code == TokenTypeEnum.Space || tokensList[currentPosition].Code == TokenTypeEnum.Invalid)
        {
            return comma(currentPosition, errors);
        }

        if (tokensList[currentPosition].Code == TokenTypeEnum.Semicolon)
        {
            errors.Add(new ErrorToken("Вставить лексему: ')'", tokensList[currentPosition].Line, currentPosition, ErrorTokenType.PUSH));
            return semicolon(currentPosition, errors);
        }

        return GetMinErrorList(
            semicolon(currentPosition, CreateErrorList(currentPosition, TokenTypeEnum.CloseParenthesis, ErrorTokenType.PUSH, errors, tokensList[currentPosition].Line)),
            semicolon(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.CloseParenthesis, ErrorTokenType.REPLACE, errors, tokensList[currentPosition].Line)),
            nextAfterArgName(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.CloseParenthesis, ErrorTokenType.DELETE, errors, tokensList[currentPosition].Line))
            );
    }
    

    private List<ErrorToken> comma(int currentPosition, List<ErrorToken> errors)
    {
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        
        if (currentPosition + 1 < tokensList.Count && tokensList[currentPosition + 1].Code == TokenTypeEnum.CloseParenthesis && tokensList[currentPosition].Code == TokenTypeEnum.Space)
        {
            return nextAfterArgName(currentPosition + 1, errors);
        }
        
        if (tokensList[currentPosition].Code == TokenTypeEnum.Comma)
        {
            return spaceComma(currentPosition + 1, errors);
        }
        
        return GetMinErrorList(
            spaceComma(currentPosition, CreateErrorList(currentPosition, TokenTypeEnum.Comma, ErrorTokenType.PUSH, errors, tokensList[currentPosition].Line)),
            spaceComma(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.Comma, ErrorTokenType.REPLACE, errors, tokensList[currentPosition].Line)),
            comma(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.Comma, ErrorTokenType.DELETE, errors, tokensList[currentPosition].Line))
        );
    }

    private List<ErrorToken> spaceComma(int currentPosition, List<ErrorToken> errors)
    {
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        
        if (tokensList[currentPosition].Code == TokenTypeEnum.Space)
        {
            return argType(currentPosition + 1, errors);
        }
        
        return GetMinErrorList(
            argType(currentPosition, CreateErrorList(currentPosition, TokenTypeEnum.Space, ErrorTokenType.PUSH, errors, tokensList[currentPosition].Line)),
            argType(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.Space, ErrorTokenType.REPLACE, errors, tokensList[currentPosition].Line)),
            spaceComma(currentPosition + 1, CreateErrorList(currentPosition, TokenTypeEnum.Space, ErrorTokenType.DELETE, errors, tokensList[currentPosition].Line))
        );
    }

    private List<ErrorToken> argType(int currentPosition, List<ErrorToken> errors)
    {
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        
        currentPosition = skipNotValid(currentPosition, errors);
        if (currentPosition >= tokensList.Count)
        {
            return errors;
        }
        if (tokensList[currentPosition].Code == TokenTypeEnum.Int ||
            tokensList[currentPosition].Code == TokenTypeEnum.Char ||
            tokensList[currentPosition].Code == TokenTypeEnum.Float ||
            tokensList[currentPosition].Code == TokenTypeEnum.Void)
        {
            return spaceAfterArgType(currentPosition + 1, errors);
        }

        return GetMinErrorList(
            spaceAfterArgType(currentPosition, CreateErrorListType(currentPosition, ErrorTokenType.PUSH, errors, tokensList[currentPosition].Line)),
            spaceAfterArgType(currentPosition + 1, CreateErrorListType(currentPosition, ErrorTokenType.REPLACE, errors, tokensList[currentPosition].Line)),
            argType(currentPosition + 1, CreateErrorListType(currentPosition, ErrorTokenType.DELETE, errors, tokensList[currentPosition].Line))
        );
    }

    private List<ErrorToken> GetMinErrorList(List<ErrorToken> errorsFirst, List<ErrorToken> errorsSecond,
        List<ErrorToken> errorsThird)
    {
        if (errorsFirst.Count < errorsSecond.Count && errorsFirst.Count < errorsThird.Count)
        {
            return errorsFirst;
        }
        else if (errorsSecond.Count < errorsThird.Count && errorsSecond.Count < errorsFirst.Count)
        {
            return errorsSecond;
        }
        return errorsThird;
    }

    private List<ErrorToken> CreateErrorList(int currentPosition, TokenTypeEnum type, ErrorTokenType errorType, List<ErrorToken> errorsCurentState, int currentLine)
    {
        List<ErrorToken> errorsNew = new List<ErrorToken>(errorsCurentState);
        errorsNew.Add(new ErrorToken(CreateErrorMessage(type, errorType, currentPosition), currentLine, currentPosition, errorType));
        return errorsNew;
    }
    
    private List<ErrorToken> CreateErrorListType(int currentPosition, ErrorTokenType errorType, List<ErrorToken> errorsCurentState, int currentLine)
    {
        List<ErrorToken> errorsNew = new List<ErrorToken>(errorsCurentState);
        errorsNew.Add(new ErrorToken(CreateErrorMessageType(errorType, currentPosition), currentLine, currentPosition, errorType));
        return errorsNew;
    }
    
    private string CreateErrorMessageType(ErrorTokenType errorType, int currentPosition)
    {
        string errorMessage = string.Empty;
        switch (errorType)
        {
            case ErrorTokenType.PUSH:
                errorMessage = $"Вставить лексему:  'char' или 'int' или 'float' или 'void'";
                break;
            case ErrorTokenType.REPLACE:
                errorMessage = $"Заменить лексему: {tokensList[currentPosition].Term} на лексему: 'char' или 'int' или 'float' или 'void'";
                break;
            case ErrorTokenType.DELETE:
                errorMessage = $"Удалить недопустимый символ '{tokensList[currentPosition].Term}'";
                break;
        }
        return errorMessage;
    }
    
    private string CreateErrorMessage(TokenTypeEnum type, ErrorTokenType errorType, int currentPosition)
    {
        string errorMessage = string.Empty;
        string lexeme;
        if (type == TokenTypeEnum.Identifier)
        {
            lexeme = type.ToString();
        }
        else
        {
            lexeme = Lexemes.getLexemes(type);
        }
        
        switch (errorType)
        {
           case ErrorTokenType.PUSH:
               errorMessage = $"Вставить лексему: '{lexeme}'";
               break;
           case ErrorTokenType.REPLACE:
               errorMessage = $"Заменить лексему: '{tokensList[currentPosition].Term}' на лексему: '{lexeme}'";
               break;
           case ErrorTokenType.DELETE:
               errorMessage = $"Удалить недопустимый символ '{tokensList[currentPosition].Term}'";
               break;
        }
        return errorMessage;
    }
}
                        </pre>
        </code>
    </div>
</div>
</body>
</html>